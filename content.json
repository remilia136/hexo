{"meta":{"title":"Hello","subtitle":null,"description":"Remilia136's personal blog (test)","author":"Remilia136","url":"https://hexo.thlremilia136.me"},"pages":[{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"client/index.html","permalink":"https://hexo.thlremilia136.me/client/index.html","excerpt":"","text":"直接下载 or 扫码下载：","keywords":"Android客户端"},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2020-03-16T10:41:30.000Z","comments":true,"path":"comment/index.html","permalink":"https://hexo.thlremilia136.me/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》","keywords":"留言板"},{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"about/index.html","permalink":"https://hexo.thlremilia136.me/about/index.html","excerpt":"","text":"[さくら荘のhojun] 与&nbsp; Mashiro&nbsp; （ 真（ま）白（しろ） ） 对话中... bot_ui_ini()","keywords":"关于"},{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"bangumi/index.html","permalink":"https://hexo.thlremilia136.me/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"donate/index.html","permalink":"https://hexo.thlremilia136.me/donate/index.html","excerpt":"","text":"","keywords":"谢谢饲主了喵~"},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"lab/index.html","permalink":"https://hexo.thlremilia136.me/lab/index.html","excerpt":"","text":"sakura主题balabala","keywords":"Lab实验室"},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2020-03-16T10:41:30.000Z","comments":true,"path":"rss/index.html","permalink":"https://hexo.thlremilia136.me/rss/index.html","excerpt":"","text":""},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"music/index.html","permalink":"https://hexo.thlremilia136.me/music/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2020-03-16T10:41:30.000Z","comments":true,"path":"tags/index.html","permalink":"https://hexo.thlremilia136.me/tags/index.html","excerpt":"","text":""},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"theme-sakura/index.html","permalink":"https://hexo.thlremilia136.me/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro","keywords":"Hexo 主题 Sakura 🌸"},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"video/index.html","permalink":"https://hexo.thlremilia136.me/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"},{"title":"zaijian","date":"2021-09-27T13:45:02.000Z","updated":"2021-09-27T13:45:02.686Z","comments":true,"path":"zaijian/index.html","permalink":"https://hexo.thlremilia136.me/zaijian/index.html","excerpt":"","text":""},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2020-03-16T10:41:30.000Z","comments":true,"path":"links/index.html","permalink":"https://hexo.thlremilia136.me/links/index.html","excerpt":"","text":"","keywords":"友人帐"}],"posts":[{"title":"hook 在组件间传递信息","slug":"2021-10-24-hook-在组件间传递信息","date":"2021-10-26T11:36:10.000Z","updated":"2021-10-26T11:51:17.153Z","comments":true,"path":"2021/10/26/2021-10-24-hook-在组件间传递信息/","link":"","permalink":"https://hexo.thlremilia136.me/2021/10/26/2021-10-24-hook-在组件间传递信息/","excerpt":"","text":"在Hook组件之间传递信息如同使用class的react组件组件一样，hook同样也可以通过状态提升，由共同的父组件进行控制和协调各个子组件之间的交互 例： const { useEffect, useState } = window.React function Money(props) { function moneyOnchange(e) { props.onChange(e.target.value) } return ( &lt;div&gt; &lt;label&gt;{props.type == &#39;r&#39; ? &#39;软妹币&#39; : &#39;日元&#39;}&lt;/label&gt; &lt;input type=&#39;text&#39; value={props.money} onChange={moneyOnchange}&gt;&lt;/input&gt; &lt;/div&gt; ) } function Main(props){ const [money , setmoney] = useState(0) const [flag , setflag] = useState(&#39;r&#39;) function yenOnchange(num){ setmoney(num) setflag(&#39;j&#39;) } function rmbOnchange(num){ setmoney(num) setflag(&#39;r&#39;) } const yen = flag === &#39;j&#39; ? money : 17.818 * parseFloat(money) const rmb = flag === &#39;r&#39; ? money : 0.05612 * parseFloat(money) return( &lt;div class = &#39;div1&#39;&gt; &lt;h1 class = &#39;h1&#39;&gt; 中日元转换&lt;/h1&gt; &lt;p&gt;1日元=0.05612人民币 1人民币 ≈ 17.818日元&lt;/p&gt; &lt;Money type=&#39;r&#39; money={rmb} onChange={rmbOnchange}/&gt; &lt;Money type=&#39;j&#39; money={yen} onChange={yenOnchange}/&gt; &lt;/div&gt; ) } ReactDOM.render( &lt;Main /&gt;, document.getElementById(&#39;root&#39;) )","categories":[{"name":"技术","slug":"技术","permalink":"https://hexo.thlremilia136.me/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"https://hexo.thlremilia136.me/categories/技术/"}]},{"title":"react hook Uncaught ReferenceError require is not defined错误","slug":"2021-10-24-react-hook-Uncaught-ReferenceError-require-is-not-defined错误","date":"2021-10-24T14:16:10.000Z","updated":"2021-10-26T11:45:28.288Z","comments":true,"path":"2021/10/24/2021-10-24-react-hook-Uncaught-ReferenceError-require-is-not-defined错误/","link":"","permalink":"https://hexo.thlremilia136.me/2021/10/24/2021-10-24-react-hook-Uncaught-ReferenceError-require-is-not-defined错误/","excerpt":"","text":"react hook Uncaught ReferenceError: require is not defined错误测试react官方文档给出的hook例子，运行时出现 Uncaught ReferenceError \\:require is not defined &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Hello React!&lt;/title&gt; &lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/react/16.13.1/umd/react.production.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/react-dom/16.13.1/umd/react-dom.production.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/babel-standalone/7.0.0-beta.3/babel.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&#39;root&#39;&gt;&lt;/div&gt; &lt;script type=&quot;text/babel&quot;&gt; import { useState } from &#39;react&#39;; function Example() { // 声明一个新的叫做 “count” 的 state 变量 const [count, setCount] = useState(0); return ( &lt;div&gt; &lt;p&gt;You clicked {count} times&lt;/p&gt; &lt;button onClick={() =&gt; setCount(count + 1)}&gt; Click me &lt;/button&gt; &lt;/div&gt; ); } ReactDOM.render( &lt;Example /&gt;, document.getElementById(&#39;root&#39;) ) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 问题及解决方法根据网友的言论推测是使用import时会调用nodejs中的require，而浏览器不支持直接运行nodejs代码 再根据网友的代码姑且可以这样解决 将 import { useState } from ‘react’; 换为const {useState } = window.React; 完整代码如下 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Hello React!&lt;/title&gt; &lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/react/16.13.1/umd/react.production.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/react-dom/16.13.1/umd/react-dom.production.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/babel-standalone/7.0.0-beta.3/babel.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&#39;root&#39;&gt;&lt;/div&gt; &lt;script type=&quot;text/babel&quot;&gt; //import { useState } from &#39;react&#39;; const {useState } = window.React; function Example() { // 声明一个新的叫做 “count” 的 state 变量 const [count, setCount] = useState(0); return ( &lt;div&gt; &lt;p&gt;You clicked {count} times&lt;/p&gt; &lt;button onClick={() =&gt; setCount(count + 1)}&gt; Click me &lt;/button&gt; &lt;/div&gt; ); } ReactDOM.render( &lt;Example /&gt;, document.getElementById(&#39;root&#39;) ) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;","categories":[{"name":"技术","slug":"技术","permalink":"https://hexo.thlremilia136.me/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"https://hexo.thlremilia136.me/categories/技术/"}]},{"title":"组合","slug":"2021-10-22-组合","date":"2021-10-22T12:35:18.000Z","updated":"2021-10-22T12:36:13.383Z","comments":true,"path":"2021/10/22/2021-10-22-组合/","link":"","permalink":"https://hexo.thlremilia136.me/2021/10/22/2021-10-22-组合/","excerpt":"","text":"组合 vs 继承React 有十分强大的组合模式。我们推荐使用组合而非继承来实现组件间的代码重用。 在这篇文档中，我们将考虑初学 React 的开发人员使用继承时经常会遇到的一些问题，并展示如何通过组合思想来解决这些问题。 包含关系有些组件无法提前知晓它们子组件的具体内容。在 Sidebar（侧边栏）和 Dialog（对话框）等展现通用容器（box）的组件中特别容易遇到这种情况。 我们建议这些组件使用一个特殊的 children prop 来将他们的子组件传递到渲染结果中： function FancyBorder(props) { return ( &lt;div className={&#39;FancyBorder FancyBorder-&#39; + props.color}&gt; {props.children} &lt;/div&gt; ); } 这使得别的组件可以通过 JSX 嵌套，将任意组件作为子组件传递给它们。 function WelcomeDialog() { return ( &lt;FancyBorder color=&quot;blue&quot;&gt; &lt;h1 className=&quot;Dialog-title&quot;&gt; Welcome &lt;/h1&gt; &lt;p className=&quot;Dialog-message&quot;&gt; Thank you for visiting our spacecraft! &lt;/p&gt; &lt;/FancyBorder&gt; ); } 在 CodePen 上尝试 &lt;FancyBorder&gt; JSX 标签中的所有内容都会作为一个 children prop 传递给 FancyBorder 组件。因为 FancyBorder 将 {props.children} 渲染在一个 &lt;div&gt; 中，被传递的这些子组件最终都会出现在输出结果中。 少数情况下，你可能需要在一个组件中预留出几个“洞”。这种情况下，我们可以不使用 children，而是自行约定：将所需内容传入 props，并使用相应的 prop。 function SplitPane(props) { return ( &lt;div className=&quot;SplitPane&quot;&gt; &lt;div className=&quot;SplitPane-left&quot;&gt; {props.left} &lt;/div&gt; &lt;div className=&quot;SplitPane-right&quot;&gt; {props.right} &lt;/div&gt; &lt;/div&gt; ); } function App() { return ( &lt;SplitPane left={ &lt;Contacts /&gt; } right={ &lt;Chat /&gt; } /&gt; ); } 在 CodePen 上尝试 &lt;Contacts /&gt; 和 &lt;Chat /&gt; 之类的 React 元素本质就是对象（object），所以你可以把它们当作 props，像其他数据一样传递。这种方法可能使你想起别的库中“槽”（slot）的概念，但在 React 中没有“槽”这一概念的限制，你可以将任何东西作为 props 进行传递。 特例关系有些时候，我们会把一些组件看作是其他组件的特殊实例，比如 WelcomeDialog 可以说是 Dialog 的特殊实例。 在 React 中，我们也可以通过组合来实现这一点。“特殊”组件可以通过 props 定制并渲染“一般”组件： function Dialog(props) { return ( &lt;FancyBorder color=&quot;blue&quot;&gt; &lt;h1 className=&quot;Dialog-title&quot;&gt; {props.title} &lt;/h1&gt; &lt;p className=&quot;Dialog-message&quot;&gt; {props.message} &lt;/p&gt; &lt;/FancyBorder&gt; ); } function WelcomeDialog() { return ( &lt;Dialog title=&quot;Welcome&quot; message=&quot;Thank you for visiting our spacecraft!&quot; /&gt; ); } 在 CodePen 上尝试 组合也同样适用于以 class 形式定义的组件。 function Dialog(props) { return ( &lt;FancyBorder color=&quot;blue&quot;&gt; &lt;h1 className=&quot;Dialog-title&quot;&gt; {props.title} &lt;/h1&gt; &lt;p className=&quot;Dialog-message&quot;&gt; {props.message} &lt;/p&gt; {props.children} &lt;/FancyBorder&gt; ); } class SignUpDialog extends React.Component { constructor(props) { super(props); this.handleChange = this.handleChange.bind(this); this.handleSignUp = this.handleSignUp.bind(this); this.state = {login: &#39;&#39;}; } render() { return ( &lt;Dialog title=&quot;Mars Exploration Program&quot; message=&quot;How should we refer to you?&quot;&gt; &lt;input value={this.state.login} onChange={this.handleChange} /&gt; &lt;button onClick={this.handleSignUp}&gt; Sign Me Up! &lt;/button&gt; &lt;/Dialog&gt; ); } handleChange(e) { this.setState({login: e.target.value}); } handleSignUp() { alert(`Welcome aboard, ${this.state.login}!`); } } 在 CodePen 上尝试 那么继承呢？在 Facebook，我们在成百上千个组件中使用 React。我们并没有发现需要使用继承来构建组件层次的情况。 Props 和组合为你提供了清晰而安全地定制组件外观和行为的灵活方式。注意：组件可以接受任意 props，包括基本数据类型，React 元素以及函数。 如果你想要在组件间复用非 UI 的功能，我们建议将其提取为一个单独的 JavaScript 模块，如函数、对象或者类。组件可以直接引入（import）而无需通过 extend 继承它们。","categories":[{"name":"技术","slug":"技术","permalink":"https://hexo.thlremilia136.me/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"https://hexo.thlremilia136.me/categories/技术/"}]},{"title":"状态提升","slug":"2021-10-22-状态提升","date":"2021-10-22T11:02:21.000Z","updated":"2021-10-22T12:35:18.397Z","comments":true,"path":"2021/10/22/2021-10-22-状态提升/","link":"","permalink":"https://hexo.thlremilia136.me/2021/10/22/2021-10-22-状态提升/","excerpt":"","text":"状态提升通常，多个组件需要反映相同的变化数据，这时可以将共享状态提升到最近的共同父组件中去。 即：在父组件中维持多个子组件的数据，子组件将直接产生的数据转交给父组件处理，父组件在进行加工后再分别传给各个子组件以供使用。 例：（中日元转换程序） &lt;div id=&#39;nihao&#39;&gt;&lt;/div&gt; &lt;script type=&#39;text/babel&#39;&gt; class Money extends React.Component { constructor(props) { super(props) this.onChange_ = this.onChange_.bind(this) } onChange_(event) { this.props.thisOnchange(event.target.value) } render() { return ( &lt;form&gt; &lt;label&gt;{this.props.type}&lt;/label&gt; &lt;input type=&#39;text&#39; onChange={this.onChange_} value={this.props.money} /&gt; &lt;/form&gt; ) } } class Convert extends React.Component { constructor(props) { super(props) this.state = { flag: &#39;r&#39;, rmb: 0, yen: 0 } this.rmbtoyen = this.rmbtoyen.bind(this) this.yentormb = this.yentormb.bind(this) } yentormb(money) { var n = parseFloat(money) this.setState({ flag: &#39;y&#39;, yen: n, rmb: 0.05612 * n }) } rmbtoyen(money) { var n = parseFloat(money) this.setState({ flag: &#39;r&#39;, yen: 17.818 * n, rmb: n }) } render() { return (&lt;div&gt; &lt;p&gt;中日元汇率&lt;/p&gt; &lt;p&gt;1日元=0.05612人民币 1人民币 ≈ 17.818日元&lt;/p&gt; &lt;Money type=&#39;软妹币&#39; thisOnchange={this.rmbtoyen} money={this.state.rmb} /&gt; &lt;Money type=&#39;日元&#39; thisOnchange={this.yentormb} money={this.state.yen} /&gt; &lt;/div&gt;) } } ReactDOM.render( &lt;Convert /&gt;, document.getElementById(&#39;nihao&#39;) ) &lt;/script&gt; 其中 yentormb(money) { var n = parseFloat(money) this.setState({ flag: &#39;y&#39;, yen: n, rmb: 0.05612 * n }) } rmbtoyen(money) { var n = parseFloat(money) this.setState({ flag: &#39;r&#39;, yen: 17.818 * n, rmb: n }) } 上方代码块为日元转换为人民币和人民币转换为日元的方法。两个方法都接收了一个“money”作为参数。该参数为日元或人民币的输入框输入时的输入框内value值，后面将这两个函数传入子组件，作为子组件的props， &lt;Money type=&#39;软妹币&#39; thisOnchange={this.rmbtoyen} money={this.state.rmb} /&gt; &lt;Money type=&#39;日元&#39; thisOnchange={this.yentormb} money={this.state.yen} /&gt; 以此子组件即可调用父组件的该函数，并将输入情况 event.target.value作为参数传给上面的函数进行处理。 onChange_(event) { this.props.thisOnchange(event.target.value) } 官方文档例子const scaleNames = { c: &#39;Celsius&#39;, f: &#39;Fahrenheit&#39; }; function toCelsius(fahrenheit) { return (fahrenheit - 32) * 5 / 9; } function toFahrenheit(celsius) { return (celsius * 9 / 5) + 32; } function tryConvert(temperature, convert) { const input = parseFloat(temperature); if (Number.isNaN(input)) { return &#39;&#39;; } const output = convert(input); const rounded = Math.round(output * 1000) / 1000; return rounded.toString(); } function BoilingVerdict(props) { if (props.celsius &gt;= 100) { return &lt;p&gt;The water would boil.&lt;/p&gt;; } return &lt;p&gt;The water would not boil.&lt;/p&gt;; } class TemperatureInput extends React.Component { constructor(props) { super(props); this.handleChange = this.handleChange.bind(this); } handleChange(e) { this.props.onTemperatureChange(e.target.value); } render() { const temperature = this.props.temperature; const scale = this.props.scale; return ( &lt;fieldset&gt; &lt;legend&gt;Enter temperature in {scaleNames[scale]}:&lt;/legend&gt; &lt;input value={temperature} onChange={this.handleChange} /&gt; &lt;/fieldset&gt; ); } } class Calculator extends React.Component { constructor(props) { super(props); this.handleCelsiusChange = this.handleCelsiusChange.bind(this); this.handleFahrenheitChange = this.handleFahrenheitChange.bind(this); this.state = {temperature: &#39;&#39;, scale: &#39;c&#39;}; } handleCelsiusChange(temperature) { this.setState({scale: &#39;c&#39;, temperature}); } handleFahrenheitChange(temperature) { this.setState({scale: &#39;f&#39;, temperature}); } render() { const scale = this.state.scale; const temperature = this.state.temperature; const celsius = scale === &#39;f&#39; ? tryConvert(temperature, toCelsius) : temperature; const fahrenheit = scale === &#39;c&#39; ? tryConvert(temperature, toFahrenheit) : temperature; return ( &lt;div&gt; &lt;TemperatureInput scale=&quot;c&quot; temperature={celsius} onTemperatureChange={this.handleCelsiusChange} /&gt; &lt;TemperatureInput scale=&quot;f&quot; temperature={fahrenheit} onTemperatureChange={this.handleFahrenheitChange} /&gt; &lt;BoilingVerdict celsius={parseFloat(celsius)} /&gt; &lt;/div&gt; ); } } ReactDOM.render( &lt;Calculator /&gt;, document.getElementById(&#39;root&#39;) ); 小结在 React 应用中，任何可变数据应当只有一个相对应的唯一“数据源”。通常，state 都是首先添加到需要渲染数据的组件中去。然后，如果其他组件也需要这个 state，那么你可以将它提升至这些组件的最近共同父组件中。你应当依靠自上而下的数据流，而不是尝试在不同组件间同步 state。 虽然提升 state 方式比双向绑定方式需要编写更多的“样板”代码，但带来的好处是，排查和隔离 bug 所需的工作量将会变少。由于“存在”于组件中的任何 state，仅有组件自己能够修改它，因此 bug 的排查范围被大大缩减了。此外，你也可以使用自定义逻辑来拒绝或转换用户的输入。 如果某些数据可以由 props 或 state 推导得出，那么它就不应该存在于 state 中。举个例子，本例中我们没有将 celsiusValue 和 fahrenheitValue 一起保存，而是仅保存了最后修改的 temperature 和它的 scale。这是因为另一个输入框的温度值始终可以通过这两个值以及组件的 render() 方法获得。这使得我们能够清除输入框内容，亦或是，在不损失用户操作的输入框内数值精度的前提下对另一个输入框内的转换数值做四舍五入的操作。 当你在 UI 中发现错误时，可以使用 React 开发者工具 来检查问题组件的 props，并且按照组件树结构逐级向上搜寻，直到定位到负责更新 state 的那个组件。这使得你能够追踪到产生 bug 的源头：","categories":[{"name":"技术","slug":"技术","permalink":"https://hexo.thlremilia136.me/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"https://hexo.thlremilia136.me/categories/技术/"}]},{"title":"表单","slug":"2021-10-18-表单","date":"2021-10-18T10:01:21.000Z","updated":"2021-10-19T14:34:16.719Z","comments":true,"path":"2021/10/18/2021-10-18-表单/","link":"","permalink":"https://hexo.thlremilia136.me/2021/10/18/2021-10-18-表单/","excerpt":"","text":"受控组件 在 HTML 中，表单元素（如&lt;input&gt;、 &lt;textarea&gt; 和 &lt;select&gt;）通常自己维护 state，并根据用户输入进行更新。而在 React 中，可变状态（mutable state）通常保存在组件的 state 属性中，并且只能通过使用 setState()来更新。 在react中 ， 可变状态（如文本框的value值）只能通过setState() 来更新，不通过setState()更新则无法修改文本框的value值 例： class Hello extends React.Component{ constructor(props){ super(props) this.state = { value_ : &#39;nihao&#39; } } render(){ return ( &lt;form&gt; &lt;label&gt;nihao&lt;/label&gt; &lt;input type=&#39;text&#39;/&gt; &lt;/form&gt; ) } } ReactDOM.render( &lt;Hello /&gt;, document.getElementById(&#39;root&#39;) ) 以上代码生成的文本框中无法进行输入 可以利用state属性来更新文本框内容 class Hello extends React.Component{ constructor(props){ super(props) this.state = { value_ : &#39;nihao&#39; } this.onch = this.onch.bind(this) this.onsubmit = this.onsubmit.bind(this) } onch(event){ this.setState({ value_ : event.target.value }) } onsubmit(){ alert(this.state.value_) } render(){ return ( &lt;form&gt; &lt;label&gt;nihao&lt;/label&gt; &lt;input type=&#39;text&#39; value=&quot;{this.state.value_}&quot; onChange={this.onch}/&gt; &lt;input type=&#39;submit&#39; value=&#39;submit&#39; onClick = {this.onsubmit}/&gt; &lt;/form&gt; ) } } ReactDOM.render( &lt;Hello /&gt;, document.getElementById(&#39;root&#39;) ) textarea 标签在 HTML 中, &lt;textarea&gt; 元素通过其子元素定义其文本: &lt;textarea&gt; 你好， 这是在 text area 里的文本 &lt;/textarea&gt; 而在 React 中，&lt;textarea&gt; 使用 value 属性代替 select 标签在 HTML 中，&lt;select&gt; 创建下拉列表标签。例如，如下 HTML 创建了水果相关的下拉列表： &lt;select&gt; &lt;option value=&quot;grapefruit&quot;&gt;葡萄柚&lt;/option&gt; &lt;option value=&quot;lime&quot;&gt;酸橙&lt;/option&gt; &lt;option selected value=&quot;coconut&quot;&gt;椰子&lt;/option&gt; &lt;option value=&quot;mango&quot;&gt;芒果&lt;/option&gt; &lt;/select&gt; 请注意，由于 selected 属性的缘故，椰子选项默认被选中。React 并不会使用 selected 属性，而是在根 select 标签上使用 value 属性。这在受控组件中更便捷，因为您只需要在根标签中更新它。 class FlavorForm extends React.Component { constructor(props) { super(props); this.state = {value: &#39;coconut&#39;}; this.handleChange = this.handleChange.bind(this); this.handleSubmit = this.handleSubmit.bind(this); } handleChange(event) { this.setState({value: event.target.value}); } handleSubmit(event) { alert(&#39;你喜欢的风味是: &#39; + this.state.value); event.preventDefault(); } render() { return ( &lt;form onSubmit={this.handleSubmit}&gt; &lt;label&gt; 选择你喜欢的风味: &lt;select value={this.state.value} onChange={this.handleChange}&gt; &lt;option value=&quot;grapefruit&quot;&gt;葡萄柚&lt;/option&gt; &lt;option value=&quot;lime&quot;&gt;酸橙&lt;/option&gt; &lt;option value=&quot;coconut&quot;&gt;椰子&lt;/option&gt; &lt;option value=&quot;mango&quot;&gt;芒果&lt;/option&gt; &lt;/select&gt; &lt;/label&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt; &lt;/form&gt; ); } } 总的来说，这使得 &lt;input type=&quot;text&quot;&gt;, &lt;textarea&gt; 和 &lt;select&gt; 之类的标签都非常相似—它们都接受一个 value 属性，你可以使用它来实现受控组件。 文件 input 标签在 HTML 中，&lt;input type=&quot;file&quot;&gt; 允许用户从存储设备中选择一个或多个文件，将其上传到服务器，或通过使用 JavaScript 的 File API 进行控制。 &lt;input type=&quot;file&quot; /&gt; 因为它的 value 只读，所以它是 React 中的一个非受控组件。 处理多个输入在一个react类中只直接使用event.target.name无法分别处理不同的表单输入 例： class Hello extends React.Component{ constructor(props){ super(props) this.state = { value_ : &#39;nihao&#39; } this.onch = this.onch.bind(this) this.onsubmit = this.onsubmit.bind(this) } onch(event){ this.setState({ value_ : event.target.value }) } onsubmit(){ alert(this.state.value_) } render(){ return ( &lt;form&gt; &lt;label&gt;nihao&lt;/label&gt; &lt;input type=&#39;text&#39; value={this.state.value_} onChange={this.onch}/&gt; &lt;input type=&#39;text&#39; value={this.state.value_} onChange={this.onch}/&gt; &lt;input type=&#39;submit&#39; value=&#39;submit&#39; onClick = {this.onsubmit}/&gt; &lt;/form&gt; ) } } ReactDOM.render( &lt;Hello /&gt;, document.getElementById(&#39;root&#39;) ) 上述代码中在表单中添加了一个相同的文本输入框，此时对其中一个文本框中修改内容另一个文本框中的内容也会同时改变 当需要处理多个 input 元素时，我们可以给每个元素添加 name 属性，并让处理函数根据 event.target.name 的值选择要执行的操作。 当需要处理多个 input 元素时，可以给每个元素添加 name 属性，并让处理函数根据 event.target.name 的值选择要执行的操作。 class Reservation extends React.Component { constructor(props) { super(props); this.state = { isGoing: true, numberOfGuests: 2 }; this.handleInputChange = this.handleInputChange.bind(this); } handleInputChange(event) { const target = event.target; const value = target.type === &#39;checkbox&#39; ? target.checked : target.value; const name = target.name; this.setState({ [name]: value }); } render() { return ( &lt;form&gt; &lt;label&gt; 参与: &lt;input name=&quot;isGoing&quot; type=&quot;checkbox&quot; checked={this.state.isGoing} onChange={this.handleInputChange} /&gt; &lt;/label&gt; &lt;br /&gt; &lt;label&gt; 来宾人数: &lt;input name=&quot;numberOfGuests&quot; type=&quot;number&quot; value={this.state.numberOfGuests} onChange={this.handleInputChange} /&gt; &lt;/label&gt; &lt;/form&gt; ); } } 通过给予每个子标签唯一的name属性，在事件处理函数中可以获取事件所对应的子标签的name属性，对每个不同的name属性生成唯一标识的state属性，以此，在每次触发事件时，事件处理函数可以分辨出是由哪一个子标签触发的事件，并进行正确的处理 受控输入空值在受控组件上指定 value 的 prop 会阻止用户更改输入，如果指定了 value，但输入仍可编辑，则可能是你意外地将value 设置为 undefined 或 null。","categories":[{"name":"技术","slug":"技术","permalink":"https://hexo.thlremilia136.me/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"https://hexo.thlremilia136.me/categories/技术/"}]},{"title":"列表&key","slug":"2021-10-15-列表&key","date":"2021-10-15T14:26:21.000Z","updated":"2021-10-15T14:34:41.945Z","comments":true,"path":"2021/10/15/2021-10-15-列表&key/","link":"","permalink":"https://hexo.thlremilia136.me/2021/10/15/2021-10-15-列表&key/","excerpt":"","text":"基础列表组件可以利用map()方法一次性加入多个组件 function NumberList(props) { const numbers = props.numbers; const listItems = numbers.map((number) =&gt; &lt;li&gt;{number}&lt;/li&gt; ); return ( &lt;ul&gt;{listItems}&lt;/ul&gt; ); } const numbers = [1, 2, 3, 4, 5]; ReactDOM.render( &lt;NumberList numbers={numbers} /&gt;, document.getElementById(&#39;root&#39;) ); keykey 帮助 React 识别哪些元素改变了，比如被添加或删除。因此你应当给数组中的每一个元素赋予一个确定的标识。 const numbers = [1, 2, 3, 4, 5]; const listItems = numbers.map((number) =&gt; &lt;li key={number.toString()}&gt; {number} &lt;/li&gt; ); 一个元素的 key 最好是这个元素在列表中拥有的一个独一无二的字符串。通常，我们使用数据中的 id 来作为元素的 key： const todoItems = todos.map((todo) =&gt; &lt;li key={todo.id}&gt; {todo.text} &lt;/li&gt; ); 当元素没有确定 id 的时候，万不得已你可以使用元素索引 index 作为 key： const todoItems = todos.map((todo, index) =&gt; // Only do this if items have no stable IDs &lt;li key={index}&gt; {todo.text} &lt;/li&gt; ); 为什么key是必须的在默认条件下，当递归 DOM 节点的子元素时，React 会同时遍历两个子元素的列表；当产生差异时，生成一个 mutation。 在子元素列表末尾新增元素时，更变开销比较小。比如： &lt;ul&gt; &lt;li&gt;first&lt;/li&gt; &lt;li&gt;second&lt;/li&gt; &lt;/ul&gt; &lt;ul&gt; &lt;li&gt;first&lt;/li&gt; &lt;li&gt;second&lt;/li&gt; &lt;li&gt;third&lt;/li&gt; &lt;/ul&gt; React 会先匹配两个 &lt;li&gt;first&lt;/li&gt; 对应的树，然后匹配第二个元素 &lt;li&gt;second&lt;/li&gt; 对应的树，最后插入第三个元素的 &lt;li&gt;third&lt;/li&gt; 树。 如果简单实现的话，那么在列表头部插入会很影响性能，那么更变开销会比较大。比如： &lt;ul&gt; &lt;li&gt;Duke&lt;/li&gt; &lt;li&gt;Villanova&lt;/li&gt; &lt;/ul&gt; &lt;ul&gt; &lt;li&gt;Connecticut&lt;/li&gt; &lt;li&gt;Duke&lt;/li&gt; &lt;li&gt;Villanova&lt;/li&gt; &lt;/ul&gt; React 会针对每个子元素 mutate 而不是保持相同的 &lt;li&gt;Duke&lt;/li&gt; 和 &lt;li&gt;Villanova&lt;/li&gt; 子树完成。这种情况下的低效可能会带来性能问题 为了解决以上问题，React 支持 key 属性。当子元素拥有 key 时，React 使用 key 来匹配原有树上的子元素以及最新树上的子元素。以下例子在新增 key 之后使得之前的低效转换变得高效： &lt;ul&gt; &lt;li key=&quot;2015&quot;&gt;Duke&lt;/li&gt; &lt;li key=&quot;2016&quot;&gt;Villanova&lt;/li&gt; &lt;/ul&gt; &lt;ul&gt; &lt;li key=&quot;2014&quot;&gt;Connecticut&lt;/li&gt; &lt;li key=&quot;2015&quot;&gt;Duke&lt;/li&gt; &lt;li key=&quot;2016&quot;&gt;Villanova&lt;/li&gt; &lt;/ul&gt; 现在 React 知道只有带着 &#39;2014&#39; key 的元素是新元素，带着 &#39;2015&#39; 以及 &#39;2016&#39; key 的元素仅仅移动了。 用 key 提取组件元素的 key 只有放在就近的数组上下文中才有意义。 比方说，如果你提取出一个 ListItem 组件，你应该把 key 保留在数组中的这个 &lt;ListItem /&gt; 元素上，而不是放在 ListItem 组件中的 &lt;li&gt; 元素上。 在哪里使用了map()方法，就在哪里添加key 例子：不正确的使用 key 的方式 function ListItem(props) { const value = props.value; return ( // 错误！你不需要在这里指定 key： &lt;li key={value.toString()}&gt; {value} &lt;/li&gt; ); } function NumberList(props) { const numbers = props.numbers; const listItems = numbers.map((number) =&gt; // 错误！元素的 key 应该在这里指定： &lt;ListItem value={number} /&gt; ); return ( &lt;ul&gt; {listItems} &lt;/ul&gt; ); } const numbers = [1, 2, 3, 4, 5]; ReactDOM.render( &lt;NumberList numbers={numbers} /&gt;, document.getElementById(&#39;root&#39;) ); 例子：正确的使用 key 的方式 function ListItem(props) { // 正确！这里不需要指定 key： return &lt;li&gt;{props.value}&lt;/li&gt;;} function NumberList(props) { const numbers = props.numbers; const listItems = numbers.map((number) =&gt; // 正确！key 应该在数组的上下文中被指定 &lt;ListItem key={number.toString()} value={number} /&gt; ); return ( &lt;ul&gt; {listItems} &lt;/ul&gt; ); } const numbers = [1, 2, 3, 4, 5]; ReactDOM.render( &lt;NumberList numbers={numbers} /&gt;, document.getElementById(&#39;root&#39;) ); key 只是在兄弟节点之间必须唯一数组元素中使用的 key 在其兄弟节点之间应该是独一无二的。然而，它们不需要是全局唯一的。当我们生成两个不同的数组时，我们可以使用相同的 key 值： function Blog(props) { const sidebar = ( &lt;ul&gt; {props.posts.map((post) =&gt; &lt;li key={post.id}&gt; {post.title} &lt;/li&gt; )} &lt;/ul&gt; ); const content = props.posts.map((post) =&gt; &lt;div key={post.id}&gt; &lt;h3&gt;{post.title}&lt;/h3&gt; &lt;p&gt;{post.content}&lt;/p&gt; &lt;/div&gt; ); return ( &lt;div&gt; {sidebar} &lt;hr /&gt; {content} &lt;/div&gt; ); } const posts = [ {id: 1, title: &#39;Hello World&#39;, content: &#39;Welcome to learning React!&#39;}, {id: 2, title: &#39;Installation&#39;, content: &#39;You can install React from npm.&#39;} ]; ReactDOM.render( &lt;Blog posts={posts} /&gt;, document.getElementById(&#39;root&#39;) ); key 会传递信息给 React ，但不会传递给你的组件。如果你的组件中需要使用 key 属性的值，请用其他属性名显式传递这个值： const content = posts.map((post) =&gt; &lt;Post key={post.id} id={post.id} title={post.title} /&gt; );","categories":[{"name":"技术","slug":"技术","permalink":"https://hexo.thlremilia136.me/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"https://hexo.thlremilia136.me/categories/技术/"}]},{"title":"条件渲染","slug":"2021-10-15-条件渲染","date":"2021-10-15T12:03:19.000Z","updated":"2021-10-15T12:31:05.949Z","comments":true,"path":"2021/10/15/2021-10-15-条件渲染/","link":"","permalink":"https://hexo.thlremilia136.me/2021/10/15/2021-10-15-条件渲染/","excerpt":"","text":"条件渲染 在 React 中，你可以创建不同的组件来封装各种你需要的行为。然后，依据应用的不同状态，你可以只渲染对应状态下的部分内容。 class H extends React.Component { constructor(props) { super(props) this.state = { flag: true } this.click_ = this.click_.bind(this) } click_() { this.setState({ flag: !this.state.flag } ) } render() { if (this.state.flag) { return &lt;Hello onClick={this.click_} /&gt; } else { return &lt;Bye onClick={this.click_} /&gt; } } } function Hello(props) { return ( &lt;div&gt; &lt;p&gt;hello&lt;/p&gt; &lt;button onClick={props.onClick}&gt;hello&lt;/button&gt; &lt;/div&gt; ) } function Bye(props) { return ( &lt;div&gt; &lt;p&gt;bye&lt;/p&gt; &lt;button onClick={props.onClick}&gt;bye&lt;/button&gt; &lt;/div&gt; ) } ReactDOM.render( &lt;H /&gt;, document.getElementById(&quot;nihao&quot;) ) 此处onclick事件处理可直接添加至自定义组件 \\&lt;Hello>或\\&lt;Bye>中。此时事件处理函数可以只需在相应的组件中的\\&lt;button>中添加props.Onclick 可以在创建组件时添加不同的参数，在组件内可以利用参数数值的不同进行不同的渲染。 与运算符 &amp;&amp; 通过花括号包裹代码，你可以在 JSX 中嵌入任何表达式。这也包括 JavaScript 中的逻辑与 (&amp;&amp;) 运算符。它可以很方便地进行元素的条件渲染。 function Mailbox(props) { const unreadMessages = props.unreadMessages; return ( &lt;div&gt; &lt;h1&gt;Hello!&lt;/h1&gt; {unreadMessages.length &gt; 0 &amp;&amp; &lt;h2&gt; You have {unreadMessages.length} unread messages. &lt;/h2&gt; } &lt;/div&gt; ); } const messages = [&#39;React&#39;, &#39;Re: React&#39;, &#39;Re:Re: React&#39;]; ReactDOM.render( &lt;Mailbox unreadMessages={messages} /&gt;, document.getElementById(&#39;root&#39;) ); 在 JavaScript 中，true &amp;&amp; expression 总是会返回 expression, 而 false &amp;&amp; expression 总是会返回 false。 因此，如果条件是 true，&amp;&amp; 右侧的元素就会被渲染，如果是 false，React 会忽略并跳过它。 三目运算符 另一种内联条件渲染的方法是使用 JavaScript 中的三目运算符 condition ? true : false。 render() { const isLoggedIn = this.state.isLoggedIn; return ( &lt;div&gt; {isLoggedIn ? &lt;LogoutButton onClick={this.handleLogoutClick} /&gt; : &lt;LoginButton onClick={this.handleLoginClick} /&gt; } &lt;/div&gt; ); } 阻止组件渲染 在极少数情况下，你可能希望能隐藏组件，即使它已经被其他组件渲染。若要完成此操作，你可以让 render 方法直接返回 null，而不进行任何渲染。 下面的示例中，&lt;WarningBanner /&gt; 会根据 prop 中 warn 的值来进行条件渲染。如果 warn 的值是 false，那么组件则不会渲染: function WarningBanner(props) { if (!props.warn) { return null; } return ( &lt;div className=&quot;warning&quot;&gt; Warning! &lt;/div&gt; ); } class Page extends React.Component { constructor(props) { super(props); this.state = {showWarning: true}; this.handleToggleClick = this.handleToggleClick.bind(this); } handleToggleClick() { this.setState(state =&gt; ({ showWarning: !state.showWarning })); } render() { return ( &lt;div&gt; &lt;WarningBanner warn={this.state.showWarning} /&gt; &lt;button onClick={this.handleToggleClick}&gt; {this.state.showWarning ? &#39;Hide&#39; : &#39;Show&#39;} &lt;/button&gt; &lt;/div&gt; ); } } ReactDOM.render( &lt;Page /&gt;, document.getElementById(&#39;root&#39;) ); 在组件的 render 方法中返回 null 并不会影响组件的生命周期。例如，上面这个示例中，componentDidUpdate 依然会被调用。","categories":[{"name":"技术","slug":"技术","permalink":"https://hexo.thlremilia136.me/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"https://hexo.thlremilia136.me/categories/技术/"}]},{"title":"10/13","slug":"2021-10-13-1013","date":"2021-10-13T14:43:19.000Z","updated":"2021-10-13T15:03:58.810Z","comments":true,"path":"2021/10/13/2021-10-13-1013/","link":"","permalink":"https://hexo.thlremilia136.me/2021/10/13/2021-10-13-1013/","excerpt":"","text":"事件处理 React 事件的命名采用小驼峰式（camelCase），而不是纯小写。 使用 JSX 语法时你需要传入一个函数作为事件处理函数，而不是一个字符串。 例如，传统的 HTML： &lt;button onclick=&quot;activateLasers()&quot;&gt; Activate Lasers &lt;/button&gt; 在 React 中略微不同： &lt;button onClick={activateLasers}&gt; Activate Lasers &lt;/button&gt; React中不能直接通过返回false取消默认行为在react中可以这样 function ActionLink() { function handleClick(e) { e.preventDefault(); console.log(&#39;The link was clicked.&#39;); } return ( &lt;a href=&quot;#&quot; onClick={handleClick}&gt; Click me &lt;/a&gt; ); } 当使用 ES6 class 语法定义一个组件的时候，通常的做法是将事件处理函数声明为 class 中的方法。例如，下面的 Toggle 组件会渲染一个让用户切换开关状态的按钮： class Toggle extends React.Component { constructor(props) { super(props); this.state = {isToggleOn: true}; // 为了在回调中使用 `this`，这个绑定是必不可少的 this.handleClick = this.handleClick.bind(this); } handleClick() { this.setState(state =&gt; ({ isToggleOn: !state.isToggleOn })); } render() { return ( &lt;button onClick={this.handleClick}&gt; {this.state.isToggleOn ? &#39;ON&#39; : &#39;OFF&#39;} &lt;/button&gt; ); } } ReactDOM.render( &lt;Toggle /&gt;, document.getElementById(&#39;root&#39;) ); this.handleClick = this.handleClick.bind(this);还不懂为什么 反正不加就不对 总之处理事件的函数必须绑定this 可以直接这么写： class Toggle extends React.Component { constructor(props) { super(props); this.state = { isToggleOn: true }; } render() { return ( &lt;button onClick={this.handleClick.bind(this)}&gt; {this.state.isToggleOn ? &#39;ON&#39; : &#39;OFF&#39;} &lt;/button&gt; ); } } 也可以把onClick内的函数改为箭头函数 如下 class LoggingButton extends React.Component { handleClick() { console.log(&#39;this is:&#39;, this); } render() { // 此语法确保 `handleClick` 内的 `this` 已被绑定。 return ( &lt;button onClick={() =&gt; this.handleClick()}&gt; Click me &lt;/button&gt; ); } } 不过这种方法会产生额外的花销 此语法问题在于每次渲染 LoggingButton 时都会创建不同的回调函数。在大多数情况下，这没什么问题，但如果该回调函数作为 prop 传入子组件时，这些组件可能会进行额外的重新渲染。我们通常建议在构造器中绑定或使用 class fields 语法来避免这类性能问题。 向事件处理程序传递参数在循环中，通常我们会为事件处理函数传递额外的参数。例如，若 id 是你要删除那一行的 ID，以下两种方式都可以向事件处理函数传递参数： &lt;button onClick={(e) =&gt; this.deleteRow(id, e)}&gt;Delete Row&lt;/button&gt; &lt;button onClick={this.deleteRow.bind(this, id)}&gt;Delete Row&lt;/button&gt; 上述两种方式是等价的，分别通过箭头函数和 Function.prototype.bind 来实现。 在这两种情况下，React 的事件对象 e 会被作为第二个参数传递。如果通过箭头函数的方式，事件对象必须显式的进行传递，而通过 bind 的方式，事件对象以及更多的参数将会被隐式的进行传递。","categories":[{"name":"技术","slug":"技术","permalink":"https://hexo.thlremilia136.me/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"https://hexo.thlremilia136.me/categories/技术/"}]},{"title":"Uncaught TypeError this.add is not a function错误及原因","slug":"function错误及原因","date":"2021-10-13T09:49:19.000Z","updated":"2021-10-13T15:06:21.981Z","comments":true,"path":"2021/10/13/function错误及原因/","link":"","permalink":"https://hexo.thlremilia136.me/2021/10/13/function错误及原因/","excerpt":"","text":"class Hello extends React.Component{ constructor(porps){ super(porps) this.state = {num : 0} } componentDidMount(){ setInterval(function(){ this.add() //此处 },1000) } componentWillUnMount(){ } add(){ this.setState({ num: this.state.num + 1 }) } render(){ return ( &lt;h1&gt;{this.state.num}&lt;/h1&gt; ) } } ReactDOM.render( &lt;Hello /&gt;, document.getElementById(&#39;example&#39;) ) 在componentDidMount方法中，直接在function(){}中使用this.add()运行时报错Uncaught TypeError: this.add is not a function 原因：在function被调用时其中的this指向调用者。此处未指明调用者，所以使用默认调用者window 即最外层作用域。而最外层作用域中不存在add函数 可修改为 `javascript class Hello extends React.Component{ constructor(porps){ super(porps) this.state = {num : 0} } componentDidMount(){ setInterval(()=&gt;{ this.add() //此处 },1000) } componentWillUnMount(){ } add(){ this.setState({ num: this.state.num + 1 }) } render(){ return ( &lt;h1&gt;{this.state.num}&lt;/h1&gt; ) }","categories":[{"name":"技术","slug":"技术","permalink":"https://hexo.thlremilia136.me/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"https://hexo.thlremilia136.me/categories/技术/"}]},{"title":"JS一些特性","slug":"JS一些特性","date":"2021-10-12T15:00:09.000Z","updated":"2021-10-12T15:43:40.457Z","comments":true,"path":"2021/10/12/JS一些特性/","link":"","permalink":"https://hexo.thlremilia136.me/2021/10/12/JS一些特性/","excerpt":"","text":"函数作用域变量在声明它们的函数体以及这个函数体嵌套的任意函数体内都是有定义的var scope=&quot;global&quot;; function t(){ console.log(scope); var scope=&quot;local&quot; console.log(scope); } t(); 输出为 undefined local 而不是 global local。 可见，在第一个console.log()时，函数内部的scope已经定义，否则console.log()会输出函数外部的global 函数内的一般变量只在函数内有效var x = &#39;a&#39; function a(){ var x = &#39;b&#39; } console.log(x) 输出为 a 例外: function t(flag){ if(flag){ s=&quot;ifscope&quot;; for(var i=0;i&lt;2;i++) ; } console.log(i); } t(true); console.log(s); 当函数内变量不进行声明 如上，直接用s = “ifscope” 输出结果为ifscope 此时s为全局变量 JS没有块级作用域function t(flag){ if(flag){ var s=&quot;ifscope&quot;; for(var i=0;i&lt;2;i++) ; } console.log(i); console.log(s); } t(true); 输出为 2 ifscope 作用域链name=&quot;lwy&quot;; function t(){ var name=&quot;tlwy&quot;; function s(){ var name=&quot;slwy&quot;; console.log(name); } function ss(){ console.log(name); } s(); ss(); } t(); 输出为slwy 和tlwy 子函数可以在自身没有定义某变量时使用夫函数的同名变量 this关键字this 永远指向调用包含自己（this本身） 的函数对应的对象。var a = 2; //window对象下的变量 function test(){ var a = 1; console.log(this.a); } test(); // 打印结果为 2 当函数在最外层直接运行，默认的对象是window 输出为undefined 此时test()的调用者为window var name = &#39;China&#39;; var obj = { name : &#39;America&#39;, show : function() { console.log(this.name) } } obj.show(); // America 此时show()的调用者是obj，所以输出的是obj对象中的name值 var name = &#39;China&#39;; var obj = { name : &#39;America&#39;, show : function() { return function(){ console.log(this.name); } } } var a = obj.show(); a(); // China 这里的 obj.show（） 返回的是一个匿名函数，相当于show()的调用者还是window ES6中箭头函数this箭头函数体内的this对象，就是定义该函数时所在的作用域指向的对象，而不是使用时所在的作用域指向的对象。var name = &#39;window&#39;; var A = { name: &#39;A&#39;, sayHello: () =&gt; { console.log(this.name) } } A.sayHello();// 还是以为输出A ? 错啦，其实输出的是window ##","categories":[{"name":"技术","slug":"技术","permalink":"https://hexo.thlremilia136.me/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"https://hexo.thlremilia136.me/categories/技术/"}]},{"title":"10/11React学习","slug":"10-11React学习","date":"2021-10-11T10:42:09.000Z","updated":"2021-10-11T14:44:10.639Z","comments":true,"path":"2021/10/11/10-11React学习/","link":"","permalink":"https://hexo.thlremilia136.me/2021/10/11/10-11React学习/","excerpt":"","text":"JSX可以生成 “React 元素”例： const element = &lt;h1&gt;Hello, world!&lt;/h1&gt;; 可以在React元素中嵌入一般的js表达式例： const name = &#39;Josh Perez&#39;; const element = &lt;h1&gt;Hello, {name}&lt;/h1&gt;; ReactDOM.render( element, document.getElementById(&#39;root&#39;) ); 若一个react标签没有内容可以使用/&gt;闭合标签例： const element = &lt;img src={user.avatarUrl} /&gt;; 假设html文件中有一处 &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; 可以通过以下语句在div中加入元素 const element = &lt;h1&gt;Hello, world&lt;/h1&gt;; ReactDOM.render(element, document.getElementById(&#39;root&#39;)); 再次使用该函数即可进行更新，且React只更新需要更新的部分 React中可以自定义组件例: function Welcome(props) { return &lt;h1&gt;Hello, {props.name}&lt;/h1&gt;; } 或使用class定义例： class Welcome extends React.Component { render() { return &lt;h1&gt;Hello, {this.props.name}&lt;/h1&gt;; } } 注:这个class名必须首字母大写，试了半天都不对最后查出来要首字母大写然后可以使用render函数加入内容 function Welcome(props) { return &lt;h1&gt;Hello, {props.name}&lt;/h1&gt;; } const element = &lt;Welcome name=&quot;Sara&quot; /&gt;; ReactDOM.render( element, document.getElementById(&#39;root&#39;) ); 可以利用自定义组件将许多组件合并为一个组件例：略 React 不允许直接在函数或class中修改props想要修改组件内容可以使用 class声明组件，并添加构造函数，为this.state赋初值例： class Clock extends React.Component { constructor(props) { super(props); this.state = {date: new Date()}; } render() { return ( &lt;div&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;h2&gt;It is {this.state.date.toLocaleTimeString()}.&lt;/h2&gt; &lt;/div&gt; ); } } 然后在class中添加componentDidMount和componentWillUnmount函数（方法）其中componentDidMount函数会在文档渲染时运行，componentWillUnmount会在文档结束生命周期时运行。此时，在componentDidMount中加入对state的修改条件，以此实现组件内部对组件内容的修改。例： class Clock extends React.Component { constructor(props) { super(props); this.state = {date: new Date()}; } componentDidMount() { this.timerID = setInterval( () =&gt; this.tick(), 1000 ); } componentWillUnmount() { clearInterval(this.timerID); } tick() { this.setState({ date: new Date() }); } render() { return ( &lt;div&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;h2&gt;It is {this.state.date.toLocaleTimeString()}.&lt;/h2&gt; &lt;/div&gt; ); } } ReactDOM.render( &lt;Clock /&gt;, document.getElementById(&#39;root&#39;) ); 注：直接用this.state = xxx修改不会进行渲染。需使用this.setState()进行修改。","categories":[{"name":"技术","slug":"技术","permalink":"https://hexo.thlremilia136.me/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"https://hexo.thlremilia136.me/categories/技术/"}]},{"title":"剩余小问题","slug":"剩余小问题","date":"2021-10-09T14:19:19.000Z","updated":"2021-10-09T14:48:24.010Z","comments":true,"path":"2021/10/09/剩余小问题/","link":"","permalink":"https://hexo.thlremilia136.me/2021/10/09/剩余小问题/","excerpt":"","text":"在归档中选项卡中的文章标题图像无法显示瞎弄了一段时间没弄好先搁置了","categories":[],"tags":[],"keywords":[]},{"title":"sakura主题中添加live2d看板娘","slug":"sakura主题中添加live2d看板娘","date":"2021-10-05T12:54:22.000Z","updated":"2021-10-05T13:31:10.199Z","comments":true,"path":"2021/10/05/sakura主题中添加live2d看板娘/","link":"","permalink":"https://hexo.thlremilia136.me/2021/10/05/sakura主题中添加live2d看板娘/","excerpt":"","text":"拿wallpaper里Neptune Live2d壁纸的live2d弄了个看板娘方法如下https://blog.csdn.net/cungudafa/article/details/104282643","categories":[{"name":"转载","slug":"转载","permalink":"https://hexo.thlremilia136.me/categories/转载/"}],"tags":[],"keywords":[{"name":"转载","slug":"转载","permalink":"https://hexo.thlremilia136.me/categories/转载/"}]},{"title":"在hexo sakura主题中添加gitalk评论","slug":"在hexo-sakura主题中添加评论","date":"2021-10-04T12:30:58.000Z","updated":"2021-10-05T13:31:31.162Z","comments":true,"path":"2021/10/04/在hexo-sakura主题中添加评论/","link":"","permalink":"https://hexo.thlremilia136.me/2021/10/04/在hexo-sakura主题中添加评论/","excerpt":"","text":"一个个贴图片太麻烦了，直接放网址吧https://blog.csdn.net/cungudafa/article/details/109065080 后来发现这个主题自带的valine不是不能用，只是我没设置 # Valine valine: true v_appId: bulabula v_appKey: bulabula 去Leancloud注册一个账号，再创建一个应用，点击应用的设置–应用key 把appID 和app key复制过来就行了不过这东西貌似并不能显示头像，gitalk可以，所以gitalk先留着。 不过gitalk有时候加载奇慢）","categories":[{"name":"转载","slug":"转载","permalink":"https://hexo.thlremilia136.me/categories/转载/"}],"tags":[],"keywords":[{"name":"转载","slug":"转载","permalink":"https://hexo.thlremilia136.me/categories/转载/"}]},{"title":"正式使用","slug":"正式使用","date":"2021-10-01T14:36:40.000Z","updated":"2021-10-01T14:56:26.405Z","comments":false,"path":"2021/10/01/正式使用/","link":"","permalink":"https://hexo.thlremilia136.me/2021/10/01/正式使用/","excerpt":"","text":"10/1日，解决或跳过n个问题后，该主题终于可以正常使用了(虽然许多功能还未完善）该主题在生成静态网页的时候不完全，尝试了别人的修改版主题，还按照某些教程进行了一些修改，均未成功，最终决定先暂时使用不完整版。另外，我发现，每次出问题，我因为嫌麻烦或对问题不了解而觉得“总不会是因为这个吧”而放置到最后尝试的解决方法，经常可以真的解决问题。该主题虽然在hexo g ，hexo s 后在localhost可以正常进入，但是无法正常生成静态网页，表现为生成的静态网页内容全部为空(0kb）public文件夹整个都是0kb。我认为，总不会是nodejs或者hexo版本不兼容吧，改版本以后用的时候还得再改回来，很麻烦。随后我“排除”了这个办法又摆式了半天。结果最后实在不行就退版本。结果正常生成了。","categories":[],"tags":[],"keywords":[]},{"title":"hello","slug":"hello","date":"2021-09-27T13:48:02.000Z","updated":"2021-09-27T13:48:02.551Z","comments":true,"path":"2021/09/27/hello/","link":"","permalink":"https://hexo.thlremilia136.me/2021/09/27/hello/","excerpt":"","text":"","categories":[],"tags":[],"keywords":[]},{"title":"nihao","slug":"nihao","date":"2021-09-27T13:34:43.000Z","updated":"2021-09-27T13:42:05.783Z","comments":true,"path":"2021/09/27/nihao/","link":"","permalink":"https://hexo.thlremilia136.me/2021/09/27/nihao/","excerpt":"","text":"nice to meet u","categories":[],"tags":[],"keywords":[]},{"title":"Hello World","slug":"hello-world","date":"2021-09-27T13:16:53.266Z","updated":"2021-09-27T13:16:53.266Z","comments":true,"path":"2021/09/27/hello-world/","link":"","permalink":"https://hexo.thlremilia136.me/2021/09/27/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new &quot;My New Post&quot; More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","categories":[],"tags":[],"keywords":[]},{"title":"Hexo-Theme-Sakura","slug":"Hexo-Theme-Sakura","date":"2018-12-12T14:16:01.000Z","updated":"2020-03-16T10:41:30.000Z","comments":true,"path":"2018/12/12/Hexo-Theme-Sakura/","link":"","permalink":"https://hexo.thlremilia136.me/2018/12/12/Hexo-Theme-Sakura/","excerpt":"","text":"hexo-theme-sakura主题 English document 基于WordPress主题Sakura修改成Hexo的主题。 demo预览 正在开发中…… 交流群若你是使用者，加群QQ: 801511924 若你是创作者，加群QQ: 194472590 主题特性 首页大屏视频 首页随机封面 图片懒加载 valine评论 fancy-box相册 pjax支持，音乐不间断 aplayer音乐播放器 多级导航菜单（按现在大部分hexo主题来说，这也算是个特性了） 赞赏作者如果喜欢hexo-theme-sakura主题，可以考虑资助一下哦~非常感激！ paypal | Alipay 支付宝 | WeChat Pay 微信支付 未完善的使用教程那啥？老实说我目前也不是很有条理233333333~ 1、主题下载安装hexo-theme-sakura建议下载压缩包格式，因为除了主题内容还有些source的配置对新手来说比较太麻烦，直接下载解压就省去这些麻烦咯。 下载好后解压到博客根目录（不是主题目录哦，重复的选择替换）。接着在命令行（cmd、bash）运行npm i安装依赖。 2、主题配置博客根目录下的_config配置站点 # Site title: 你的站点名 subtitle: description: 站点简介 keywords: author: 作者名 language: zh-cn timezone: 部署 deploy: type: git repo: github: 你的github仓库地址 # coding: 你的coding仓库地址 branch: master 备份 （使用hexo b发布备份到远程仓库） backup: type: git message: backup my blog of https://honjun.github.io/ repository: # 你的github仓库地址,备份分支名 （建议新建backup分支） github: https://github.com/honjun/honjun.github.io.git,backup # coding: https://git.coding.net/hojun/hojun.git,backup 主题目录下的_config配置其中标明【改】的是需要修改部门，标明【选】是可改可不改，标明【非】是不用改的部分 # site name # 站点名 【改】 prefixName: さくら荘その siteName: hojun # favicon and site master avatar # 站点的favicon和头像 输入图片路径（下面的配置是都是cdn的相对路径，没有cdn请填写完整路径，建议使用jsdeliver搭建一个cdn啦，先去下载我的cdn替换下图片就行了，简单方便~）【改】 favicon: /images/favicon.ico avatar: /img/custom/avatar.jpg # 站点url 【改】 url: https://sakura.hojun.cn # 站点介绍（或者说是个人签名）【改】 description: Live your life with passion! With some drive! # 站点cdn，没有就为空 【改】 若是cdn为空，一些图片地址就要填完整地址了，比如之前avatar就要填https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/custom/avatar.jpg cdn: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6 # 开启pjax 【选】 pjax: 1 # 站点首页的公告信息 【改】 notice: hexo-Sakura主题已经开源，目前正在开发中... # 懒加载的加载中图片 【选】 lazyloadImg: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/loader/orange.progress-bar-stripe-loader.svg # 站点菜单配置 【选】 menus: 首页: { path: /, fa: fa-fort-awesome faa-shake } 归档: { path: /archives, fa: fa-archive faa-shake, submenus: { 技术: {path: /categories/技术/, fa: fa-code }, 生活: {path: /categories/生活/, fa: fa-file-text-o }, 资源: {path: /categories/资源/, fa: fa-cloud-download }, 随想: {path: /categories/随想/, fa: fa-commenting-o }, 转载: {path: /categories/转载/, fa: fa-book } } } 清单: { path: javascript:;, fa: fa-list-ul faa-vertical, submenus: { 书单: {path: /tags/悦读/, fa: fa-th-list faa-bounce }, 番组: {path: /bangumi/, fa: fa-film faa-vertical }, 歌单: {path: /music/, fa: fa-headphones }, 图集: {path: /tags/图集/, fa: fa-photo } } } 留言板: { path: /comment/, fa: fa-pencil-square-o faa-tada } 友人帐: { path: /links/, fa: fa-link faa-shake } 赞赏: { path: /donate/, fa: fa-heart faa-pulse } 关于: { path: /, fa: fa-leaf faa-wrench , submenus: { 我？: {path: /about/, fa: fa-meetup}, 主题: {path: /theme-sakura/, fa: iconfont icon-sakura }, Lab: {path: /lab/, fa: fa-cogs }, } } 客户端: { path: /client/, fa: fa-android faa-vertical } RSS: { path: /atom.xml, fa: fa-rss faa-pulse } # Home page sort type: -1: newer first，1: older first. 【非】 homePageSortType: -1 # Home page article shown number) 【非】 homeArticleShown: 10 # 背景图片 【选】 bgn: 8 # startdash面板 url, title, desc img 【改】 startdash: - {url: /theme-sakura/, title: Sakura, desc: 本站 hexo 主题, img: /img/startdash/sakura.md.png} - {url: http://space.bilibili.com/271849279, title: Bilibili, desc: 博主的b站视频, img: /img/startdash/bilibili.jpg} - {url: /, title: hojun的万事屋, desc: 技术服务, img: /img/startdash/wangshiwu.jpg} # your site build time or founded date # 你的站点建立日期 【改】 siteBuildingTime: 07/17/2018 # 社交按钮(social) url, img PC端配置 【改】 social: github: {url: http://github.com/honjun, img: /img/social/github.png} sina: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/sina.png} wangyiyun: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/wangyiyun.png} zhihu: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/zhihu.png} email: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/email.svg} wechat: {url: /#, qrcode: /img/custom/wechat.jpg, img: /img/social/wechat.png} # 社交按钮(msocial) url, img 移动端配置 【改】 msocial: github: {url: http://github.com/honjun, fa: fa-github, color: 333} weibo: {url: http://weibo.com/mashirozx?is_all=1, fa: fa-weibo, color: dd4b39} qq: {url: https://wpa.qq.com/msgrd?v=3&amp;uin=954655431&amp;site=qq&amp;menu=yes, fa: fa-qq, color: 25c6fe} # 赞赏二维码（其中wechatSQ是赞赏单页面的赞赏码图片）【改】 donate: alipay: /img/custom/donate/AliPayQR.jpg wechat: /img/custom/donate/WeChanQR.jpg wechatSQ: /img/custom/donate/WeChanSQ.jpg # 首页视频地址为https://cdn.jsdelivr.net/gh/honjun/hojun@1.2/Unbroken.mp4，配置如下 【改】 movies: url: https://cdn.jsdelivr.net/gh/honjun/hojun@1.2 # 多个视频用逗号隔开，随机获取。支持的格式目前已知MP4,Flv。其他的可以试下，不保证有用 name: Unbroken.mp4 # 左下角aplayer播放器配置 主要改id和server这两项，修改详见[aplayer文档] 【改】 aplayer: id: 2660651585 server: netease type: playlist fixed: true mini: false autoplay: false loop: all order: random preload: auto volume: 0.7 mutex: true # Valine评论配置【改】 valine: true v_appId: GyC3NzMvd0hT9Yyd2hYIC0MN-gzGzoHsz v_appKey: mgOpfzbkHYqU92CV4IDlAUHQ 分类页和标签页配置分类页 标签页 配置项在\\themes\\Sakura\\languages\\zh-cn.yml里。新增一个分类或标签最好加下哦，当然嫌麻烦可以直接使用一张默认图片（可以改主题或者直接把404图片替换下，征求下意见要不要给这个在配置文件中加个开关，可以issue或群里提出来），现在是没设置的话会使用那种倒立小狗404哦。 #category # 按分类名创建 技术: #中文标题 zh: 野生技术协会 # 英文标题 en: Geek – Only for Love # 封面图片 img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/coding.jpg 生活: zh: 生活 en: live img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/writing.jpg #tag # 标签名即是标题 悦读: # 封面图片 img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/reading.jpg 单页面封面配置如留言板页面页面，位于source下的comment下，打开index.md如下： --- title: comment date: 2018-12-20 23:13:48 keywords: 留言板 description: comments: true # 在这里配置单页面头部图片，自定义替换哦~ photos: https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/comment.jpg --- 单页面配置番组计划页 （请直接在下载后的文件中改，下面的添加了注释可能会有些影响） --- layout: bangumi title: bangumi comments: false date: 2019-02-10 21:32:48 keywords: description: bangumis: # 番组图片 - img: https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg # 番组名 title: 朝花夕誓——于离别之朝束起约定之花 # 追番状态 （追番ing/已追完） status: 已追完 # 追番进度 progress: 100 # 番剧日文名称 jp: さよならの朝に約束の花をかざろう # 放送时间 time: 放送时间: 2018-02-24 SUN. # 番剧介绍 desc: 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。 - img: https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg title: 朝花夕誓——于离别之朝束起约定之花 status: 已追完 progress: 50 jp: さよならの朝に約束の花をかざろう time: 放送时间: 2018-02-24 SUN. desc: 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。 --- 友链页 （请直接在下载后的文件中改，下面的添加了注释可能会有些影响） --- layout: links title: links # 创建日期，可以改下 date: 2018-12-19 23:11:06 # 图片上的标题，自定义修改 keywords: 友人帐 description: # true/false 开启/关闭评论 comments: true # 页面头部图片，自定义修改 photos: https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/links.jpg # 友链配置 links: # 类型分组 - group: 个人项目 # 类型简介 desc: 充分说明这家伙是条咸鱼 &lt; (￣︶￣)&gt; items: # 友链链接 - url: https://shino.cc/fgvf # 友链头像 img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg # 友链站点名 name: Google # 友链介绍 下面雷同 desc: Google 镜像 - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 # 类型分组... - group: 小伙伴们 desc: 欢迎交换友链 ꉂ(ˊᗜˋ) items: - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 --- 写文章配置主题集成了个人插件hexo-tag-bili和hexo-tag-fancybox_img。其中hexo-tag-bili用来在文章或单页面中插入B站外链视频，使用语法如下： {% bili video_id [page] %} 详细使用教程详见hexo-tag-bili。 hexo-tag-fancybox_img用来在文章或单页面中图片，使用语法如下： {% fb_img src [caption] %} 详细使用教程详见hexo-tag-fancybox_img 还有啥，一时想不起来……To be continued…","categories":[{"name":"技术","slug":"技术","permalink":"https://hexo.thlremilia136.me/categories/技术/"}],"tags":[{"name":"web","slug":"web","permalink":"https://hexo.thlremilia136.me/tags/web/"},{"name":"悦读","slug":"悦读","permalink":"https://hexo.thlremilia136.me/tags/悦读/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://hexo.thlremilia136.me/categories/技术/"}]}]}